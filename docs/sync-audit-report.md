# Google Drive 同期 衝突回避アルゴリズム 総合監査レポート

> **作成日**: 2026-02-10
> **監査対象**: backend/drive_service.go, drive_operations_queue.go, drive_sync_service.go, drive_operations.go, drive_polling.go, auth_service.go, app_logger.go, frontend/src/hooks/useDriveSync.ts
> **目的**: 同期衝突回避アルゴリズムの堅牢性とUXフィードバックの網羅的評価

---

## 総評

現在の衝突解決は基本的に **Last-Writer-Wins（デバイスクロック依存）** で、単一デバイス運用ではおおむね安全だが、**マルチデバイス・オフライン復帰時に構造データ（フォルダ/並び順/アーカイブ）が上書きされ、ノートのサイレント削除が発生する経路が複数存在**する。

### 現在のアーキテクチャ概要

```
SyncNotes() フロー:
1. キューにアイテムがあればスキップ（※バグ：実際にはスキップしていない）
2. 接続状態確認
3. FileIDキャッシュ更新
4. noteList.json を MD5 チェックでダウンロード判定
5. クラウド noteList なし → 全ローカルノートをアップロード
6. 同じ LastSync:
   a. コンテンツ違う → mergeNotes
   b. 同じ → 完了
7. クラウド LastSync > ローカル → handleCloudSync（クラウド優先）
8. ローカル LastSync > クラウド → handleLocalSync（ローカル優先）
```

```
mergeNotes() フロー:
- 両方存在 + 同じ ContentHash → ローカル維持
- 両方存在 + 異なる ContentHash:
  - クラウド ModifiedTime > ローカル → ダウンロード
  - ローカル ModifiedTime >= クラウド → アップロード
- ローカルのみ → アップロード
- クラウドのみ → ダウンロード
```

---

## A. コンテンツ衝突

### A1: 同一ノートを2台で同時編集（オンライン）

- **対応状況**: 部分的
- **現在の動作**: `Note.ModifiedTime` のLWW。`NoteList.LastSync` で同期方向が決まり、ノート単位の比較は二次的
- **正しいか**: No（クロックスキュー + 構造上書き）
- **UXフィードバック**: なし（汎用ログ/ステータスのみ）
- **リスクレベル**: 🟠 High
- **推奨**: Drive metadata で順序付け + 異なるハッシュ時は "conflicted copy" を作成して上書きしない

### A2: 一台が短時間オフライン後に復帰、同一ノート編集

- **対応状況**: 部分的
- **現在の動作**: `ModifiedTime` 文字列によるLWW
- **正しいか**: クロックとnoteList更新状況に依存
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High
- **推奨**: ノート単位で "last seen cloud revision" を保持し、オフライン発散を明示的に検出

### A3: 両方のデバイスがオフラインで同一ノート編集後、両方復帰

- **対応状況**: 部分的
- **現在の動作**: 後からアップロードした側（またはデバイス時刻が遅い側）が勝つ
- **正しいか**: No（マージなし、ユーザー選択なし）
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High
- **推奨**: コンフリクトコピー + ユーザー通知（"2つのバージョンが保存されました"）

### A4: 一台で高速連続編集中にsync/pollingが走る

- **対応状況**: 弱い
- **現在の動作**: 複数 `SaveNote()` + Driveキューデバウンスが可視性を変える
- **正しいか**: 確実ではない
- **UXフィードバック**: syncing/syncedの切り替え、ノート単位の確実性なし
- **リスクレベル**: 🟡 Medium/High
- **推奨**: アプリレベルの単一デバウンス層 + ノートアップロードとnoteListアップロードの直列化

### A5: 別の同期が同じノートをダウンロード中にローカル編集

- **対応状況**: 部分的
- **現在の動作**: `syncNoteCloudToLocal()` はクラウド `ModifiedTime` が新しい場合のみ上書き
- **正しいか**: クロック依存
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟡 Medium
- **推奨**: ダウンロード/適用中のノート単位ロック or リトライ付きコンフリクト検出

### A6: デバイスクロックスキュー（高速/低速なラップトップ）

- **対応状況**: No
- **現在の動作**: `isModifiedTimeAfter()` が使用される全箇所で誤った勝者選択
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High
- **推奨**: Driveサーバータイムスタンプ/リビジョンを使用し、デバイス時刻はヒントのみにする

### A7: noteList.json を更新せずに Drive 上のノートファイルだけ変更（外部編集/部分失敗）

- **対応状況**: No
- **現在の動作**: noteList MD5 未変更時は `DownloadNoteListIfChanged` でスキップ → ノートファイルの変更を見落とす
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High
- **推奨**: ノート単位のファイル MD5/modifiedTime を追跡、または定期的な "notes フォルダスキャン" 整合性チェック

### A8: NoteListメタデータハッシュは異なるがコンテンツは同一（ハッシュに ModifiedTime 含む）

- **対応状況**: Yes（ただしノイジー）
- **現在の動作**: `ContentHash` が `ModifiedTime` 変更で変わる → 不要なアップロード/ダウンロード
- **正しいか**: 技術的には一貫しているが非効率
- **UXフィードバック**: 余分な同期ちらつき
- **リスクレベル**: 🟢 Low/Medium
- **推奨**: タイムスタンプ除外の安定コンテンツフィールドのみハッシュ化

---

## B. 構造的衝突（削除/アーカイブ/フォルダ/並び順）

### B1: デバイスAで削除、デバイスBで編集

- **対応状況**: ほぼ No
- **現在の動作**: クラウドnoteListにノートがない場合、cloud-syncパスでローカル編集済みノートファイルを **サイレント削除** (`handleCloudSync`)
- **正しいか**: No（トゥームストーンなし / コンフリクトコピーなし）
- **UXフィードバック**: サイレント削除
- **リスクレベル**: 🔴 Critical
- **推奨**: トゥームストーン + 猶予期間 + コンフリクトコピーでハード削除を置換

### B2: 一台オフライン中の削除 vs 編集

- **対応状況**: 部分的
- **現在の動作**: `NoteList.LastSync` の新しさ（デバイスクロック）で勝者決定、cloud→local でハード削除可能
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High
- **推奨**: 削除はユーザー可視の解決を必要とするコンフリクト、またはトゥームストーン優先ルール

### B3: アーカイブ/アンアーカイブ vs 同一ノート編集

- **対応状況**: 部分的
- **現在の動作**: `ModifiedTime` によるLWW
- **正しいか**: フォルダアーカイブパスがノート `ModifiedTime` を更新しない（`SaveNoteFromSync` 使用）ため不正確になりがち
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High
- **推奨**: セマンティック変更ごとに比較可能なバージョンフィールドを更新

### B4: デバイスAでフォルダアーカイブ、デバイスBでフォルダ内ノート編集

- **対応状況**: No/部分的
- **現在の動作**: フォルダアーカイブ変更がコンフリクトとして確実に伝播しない（ノートタイムスタンプが変わらない可能性）
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High
- **推奨**: フォルダアーカイブをバージョニング付き明示的状態として表現

### B5: デバイスAでフォルダ移動、デバイスBで別フォルダに移動

- **対応状況**: No
- **現在の動作**: フォルダ所属は `noteList.json` のみ。同期ロジックが `Folders`/orders をマージせず、cloud-winsパスがクラウドfoldersを適用しない
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High
- **推奨**: noteList全体をマージ/適用（Notesだけでなく）

### B6: フォルダ作成/名前変更/削除の衝突

- **対応状況**: No
- **現在の動作**: 最後にnoteListをアップロードした側が他方を上書き（`Folders` のマージなし）
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High
- **推奨**: フォルダ単位のフィールドマージ + 安定ID + フォルダIDごとのLWW

### B7: TopLevelOrder の衝突（2台で並び替え）

- **対応状況**: No
- **現在の動作**: cloud-winsがクラウド `TopLevelOrder` を採用せず、ローカルリストをアップロードしてクラウドを上書き
- **正しいか**: No
- **UXフィードバック**: サイレント（並び順ロス）
- **リスクレベル**: 🟠 High
- **推奨**: orderのマージ or 決定論的勝者の明示的反映

### B8: ArchivedTopLevelOrder の衝突

- **対応状況**: No
- **現在の動作**: B7と同様
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟡 Medium/High
- **推奨**: ArchivedOrderの個別マージ or メタデータからの決定論的再生成

### B9: 同一 LastSync で構造のみ変更（レアだが可能）

- **対応状況**: No
- **現在の動作**: equal-LastSyncマージパスはnotesのみマージし、`ContentHash`/`Order` のみ変更比較
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟡 Medium
- **推奨**: folder/order/folderId/archived の変更も等価性チェック+マージに含める

---

## C. タイミング / レースコンディション

### C1: `skipSyncIfQueuePending` が実際にスキップしない

- **対応状況**: No（バグ）
- **現在の動作**: ログ出力のみで `return nil` → キュー未処理のまま同期実行
- **正しいか**: No
- **UXフィードバック**: 不可視
- **リスクレベル**: 🟠 High
- **推奨**: キュー非空時に実際に同期をabort or キューをdrain/await

### C2: CREATE 後のキューマップ不整合でポーリング停止

- **対応状況**: No（バグ）
- **現在の動作**: `FileID` 空で追加→CREATE後にmutate→`removeItemFromMap()` で見つからない→`HasItems()` 永久true→**ポーリング/自動同期停止**
- **正しいか**: No
- **UXフィードバック**: リモート変更が到達しなくなる
- **リスクレベル**: 🔴 Critical
- **推奨**: mutableな `FileID` をキーにしない。`(opType, fileName, parentID)` 等の安定キー使用

### C3: 並行 SyncNotes 呼出

- **対応状況**: Yes
- **現在の動作**: `syncMu` で排他制御
- **正しいか**: 概ねOK
- **UXフィードバック**: "syncing" のみ
- **リスクレベル**: 🟢 Low/Medium

### C4: ノートダウンロード後・noteList更新前のクラッシュ

- **対応状況**: 部分的
- **現在の動作**: ローカルファイル上書き済みだがメタデータ未更新。次回起動で `ValidateIntegrity()` が修復試行（不完全）
- **正しいか**: No（アトミックでない、復活/再削除の可能性）
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟡 Medium/High
- **推奨**: ステージングエリアに適用後スワップ（orジャーナル）

### C5: 同期中のトークン期限切れ / 一時的401

- **対応状況**: 過激
- **現在の動作**: 401でトークン削除 + initial-syncフラグ削除（完全オフライン遷移）
- **正しいか**: 一時的な認証失敗には過剰
- **UXフィードバック**: 予期しない再ログイン要求
- **リスクレベル**: 🟡 Medium/High
- **推奨**: revokedトークンと一時的エラーを区別。トークン削除前にリフレッシュをリトライ

### C6: 同一 LastSync で内容が発散

- **対応状況**: 部分的
- **現在の動作**: notesのみマージ後、ローカルnoteListをアップロード
- **正しいか**: 構造的にNo
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟡 Medium

### C7: Changes API トークンロス

- **対応状況**: Yes
- **現在の動作**: トークン欠損/無効時はフルシンクフォールバック
- **正しいか**: OK
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟢 Low

---

## D. データ整合性

### D1: noteListが存在しないローカルノートファイルを参照

- **対応状況**: Yes（ローカルのみ）
- **現在の動作**: `ValidateIntegrity()` がファイルなしエントリを除去
- **正しいか**: ローカルは一貫するが、後の同期で意図しないクラウド削除の原因になりうる
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟡 Medium
- **推奨**: 除去前に "missing" マーク + 再ダウンロード試行

### D2: noteListにないローカル孤立ノートファイル

- **対応状況**: Yes（ローカルのみ）
- **現在の動作**: `ValidateIntegrity()` がnoteListに復活させるが、`ContentHash`/Order/FolderID なし
- **正しいか**: 部分的
- **UXフィードバック**: サイレント（"ノート再出現"）
- **リスクレベル**: 🟡 Medium
- **推奨**: フルメタデータ（hash/order/folder）を再計算後、修復済みnoteListをアップロード

### D3: クラウドnoteListにないクラウド孤立ノートファイル

- **対応状況**: Yes（ただし破壊的）
- **現在の動作**: ポーリング開始時とローカル同期パスで、ダウンロード/バックアップなしに **自動削除**
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🔴 Critical
- **推奨**: 不明ノートは自動削除しない。ダウンロード&マージ or "trash" フォルダへ移動

### D4: クラウドの重複ノートファイル

- **対応状況**: 部分的（リスクあり）
- **現在の動作**: Drive `createdTime`（modifiedTimeではない）でソートし、最新以外を削除
- **正しいか**: No（最新コンテンツが削除される可能性）
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High
- **推奨**: Drive `modifiedTime`/MD5 and/or ノートJSON `ModifiedTime` で重複排除

### D5: クラウド noteList.json のJSON破損

- **対応状況**: No
- **現在の動作**: unmarshalエラー → オフライン遷移。`drive_polling.go` で `cloudNoteList=nil` のままデリファレンスの可能性
- **正しいか**: No
- **UXフィードバック**: ランダムなオフライン表示
- **リスクレベル**: 🟠 High
- **推奨**: バリデーション + 直前の正常なバックアップ保持 + 何も削除せずにグレースフルフェイル

### D6: クラウドノートJSONの破損

- **対応状況**: No
- **現在の動作**: 単一ノートのデコード失敗でマージ/同期全体がabort → オフライン遷移可能
- **正しいか**: No
- **UXフィードバック**: 汎用エラー
- **リスクレベル**: 🟡 Medium/High
- **推奨**: 破損ノートをスキップ + 隔離 + 残りの同期を継続

### D7: 削除されたクラウド noteList ファイル（noteList.json 消失）

- **対応状況**: 弱い
- **現在の動作**: 同期がエラーアウト。"upload all local" パスは `UploadAllNotes()` が `Content` なしで `Note` を構築するため不安全
- **正しいか**: No
- **UXフィードバック**: 汎用オフライン
- **リスクレベル**: 🟠 High/Critical
- **推奨**: 再作成時はローカルコンテンツを読み込んで実際のノートファイルをアップロード

### D8: サイズ/遅延制限（大きなノート、遅いネットワーク）

- **対応状況**: リトライで部分対応
- **現在の動作**: リトライは文字列マッチベース。resumable uploadなし
- **UXフィードバック**: オフラインに遷移可能
- **リスクレベル**: 🟡 Medium
- **推奨**: 大きなコンテンツにはDrive resumable uploadsを使用 + エラー分類を厳格化

---

## E. オフライン / 再接続

### E1: 長期オフライン（多数の変更あり）→ 復帰

- **対応状況**: 部分的
- **現在の動作**: list-level `LastSync` で方向決定。ノート単位の `ModifiedTime` が上書きを時に防止するが、構造データは上書き
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High
- **推奨**: 再接続後の明示的 "reconcile session" + コンフリクトコピー

### E2: 同期中の一時的ネットワーク途絶

- **対応状況**: Poor UX
- **現在の動作**: バックエンドは temporary offline（トークン保持）にするが、フロントエンドの同期監視が `LogoutDrive()` を呼出 → **トークン削除 + 再ログイン強制**
- **正しいか**: No
- **UXフィードバック**: 驚きのログアウト
- **リスクレベル**: 🟡 Medium/High
- **推奨**: temporary offlineでは強制ログアウトしない。トークン保持 + "retrying" 表示

### E3: デバイスAでオフライン削除、デバイスBでクラウド編集

- **対応状況**: No
- **現在の動作**: タイミングにより削除済みノートの復活 or 編集済みノートの削除が起こりうる
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High
- **推奨**: 削除はトゥームストーン化し、ファーストクラスの操作として同期

### E4: デバイスAとBの両方がオフラインで新規ノート作成

- **対応状況**: 概ねOK
- **現在の動作**: UUID IDで衝突回避。ただし後の "unknown note deletion" がnoteList更新のラグで新規ノートを削除する可能性
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High
- **推奨**: unknown削除の廃止 + クリーンアップ前にnoteList更新を必須化

### E5: オフライン中のフォルダ移動/並び替え操作

- **対応状況**: No
- **現在の動作**: noteListフィールドが正しくマージ/適用されないため構造変更が上書き
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High

### E6: 再インストール / ローカルnoteList消失（ローカルノートファイルは存在）

- **対応状況**: リスクあり
- **現在の動作**: cloud-winsパスがローカル専用ノートファイルを削除可能（manual-login初期マージ除く）
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟠 High
- **推奨**: ローカル状態がある場合は常に安全な "initial merge" を実行

---

## F. キュー固有

### F1: CREATE操作後のキューステート不整合

- **対応状況**: No（バグ）
- **現在の動作**: `FileID` 空で追加→CREATE後にmutate→`removeItemFromMap()` で見つからない→`HasItems()` 永久true→**ポーリング/自動同期停止**
- **正しいか**: No
- **UXフィードバック**: ポーリング/自動同期が停止
- **リスクレベル**: 🔴 Critical
- **推奨**: mutableな `FileID` をキーにしない。`originalKey` 保存 or `(opType, fileName, parentID)` をキーに使用

### F2: UPDATE取消 → 重複CREATE

- **対応状況**: No（バグ）
- **現在の動作**: キャンセルされたUPDATEがerror返却→`UpdateNote()` がerrorを見て `CreateNote()` 呼出→**同一ノートのDriveファイル重複生成**
- **正しいか**: No
- **UXフィードバック**: サイレント
- **リスクレベル**: 🔴 Critical
- **推奨**: "cancelled" errorをno-op（nil）として伝播。そのクラスのエラーでは決してCreateしない

### F3: DELETE が同一ファイルの既存操作をキャンセル

- **対応状況**: Yes
- **現在の動作**: FileID でキャンセル
- **正しいか**: 部分的（空/unknown FileIDのcreateをカバーしない、"delete then recreate" セマンティクス未対応）
- **UXフィードバック**: サイレント
- **リスクレベル**: 🟡 Medium
- **推奨**: 安定した noteID/fileName でキャンセル + 望ましい最終状態の追跡

### F4: 遅延goroutine実行中のCleanup

- **対応状況**: No
- **現在の動作**: `Cleanup()` がチャネルclose → 遅延debounce goroutineがclose済みチャネルにsend → **panic**
- **正しいか**: No
- **UXフィードバック**: クラッシュ
- **リスクレベル**: 🟠 High
- **推奨**: enqueue前に `ctx.Done()` チェック + タイマー存在中の共有チャネルclose回避

### F5: アプリ終了時のキューflush

- **対応状況**: 弱い
- **現在の動作**: 保留中の操作がUIより長生きする可能性。flush保証なし
- **正しいか**: 状況依存
- **UXフィードバック**: キュー未消化でも "synced" になりうる
- **リスクレベル**: 🟡 Medium
- **推奨**: "synced" 表示前 or シャットダウン前に明示的drain（`WaitForEmpty`）

### F6: エラーが同期全体をブロック

- **対応状況**: 部分的
- **現在の動作**: 1つの操作失敗でマージ全体停止 or オフライン遷移
- **正しいか**: No
- **UXフィードバック**: 汎用エラー
- **リスクレベル**: 🟡 Medium
- **推奨**: ノート単位で失敗を分離 + 残りの同期を継続 + ノート単位の失敗をsurface

---

## G. UXフィードバックのギャップ

### G1: ユーザーがコンフリクト発生を知る手段がない

- **対応状況**: No
- **現在の動作**: 自動上書き/削除は汎用ログのみ（ステータスバーで一瞬表示→フェードアウト）
- **正しいか**: No（コア機能として不十分）
- **UXフィードバック**: 不十分
- **リスクレベル**: 🟠 High
- **推奨**: 明示的 `drive:conflict` イベント発行 + 両バージョン保持

### G2: サイレントな破壊的削除

- **対応状況**: No
- **現在の動作**: ローカル専用削除・クラウドunknownノート削除のいずれも確認なし・リカバリなし
- **正しいか**: No
- **UXフィードバック**: データ消失のサプライズ
- **リスクレベル**: 🔴 Critical
- **推奨**: trash/quarantine に移動 + "X件が隔離されました" バナー表示

### G3: "Synced" ステータスの信頼性

- **対応状況**: No
- **現在の動作**: コードパス完了 = synced（"キュー消化 + リモート状態検証" ではない）
- **正しいか**: No
- **UXフィードバック**: 偽の安心感
- **リスクレベル**: 🟡 Medium/High
- **推奨**: キュー空 + 検証読み取り後のみ "synced" 表示（最低でもnoteListアップロード成功後）

### G4: 一時的問題での強制ログアウト

- **対応状況**: Poor
- **現在の動作**: フロントエンドの一部エラーパスで `LogoutDrive()` 呼出 → トークン削除 + 再ログイン強制
- **正しいか**: No
- **UXフィードバック**: 摩擦 + 未同期作業の孤立
- **リスクレベル**: 🟡 Medium/High
- **推奨**: リトライ + トークン保持。ログアウトは明示的ユーザーアクション or 確認済みrevokeのみ

### G5: 同期レポートなし

- **対応状況**: No
- **現在の動作**: ログは存在するが構造化されていない（何が変わった、何がダウンロード/アップロード/削除された）
- **正しいか**: 信頼性に欠ける
- **UXフィードバック**: 信頼しにくい
- **リスクレベル**: 🟡 Medium
- **推奨**: 小さな同期後サマリー表示（"3件アップロード、1件ダウンロード、1件コンフリクト、2件隔離"）

---

## リスクレベル集計

| レベル | 件数 | シナリオ |
|--------|------|---------|
| 🔴 Critical | 5 | B1, C2/F1, D3, F2, G2 |
| 🟠 High | 19 | A1-A3, A6, A7, B2-B8, C1, C5, D4, D5, D7, E1-E4, F4, G1 |
| 🟡 Medium | 14 | A4, A5, A8, B9, C4, C6, D1, D2, D6, D8, E2, F3, F5, F6, G3-G5 |
| 🟢 Low | 2 | C3, C7 |
